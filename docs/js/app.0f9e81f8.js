(function(e){function t(t){for(var l,o,n=t[0],r=t[1],i=t[2],u=0,p=[];u<n.length;u++)o=n[u],Object.prototype.hasOwnProperty.call(c,o)&&c[o]&&p.push(c[o][0]),c[o]=0;for(l in r)Object.prototype.hasOwnProperty.call(r,l)&&(e[l]=r[l]);b&&b(t);while(p.length)p.shift()();return d.push.apply(d,i||[]),a()}function a(){for(var e,t=0;t<d.length;t++){for(var a=d[t],l=!0,n=1;n<a.length;n++){var r=a[n];0!==c[r]&&(l=!1)}l&&(d.splice(t--,1),e=o(o.s=a[0]))}return e}var l={},c={app:0},d=[];function o(t){if(l[t])return l[t].exports;var a=l[t]={i:t,l:!1,exports:{}};return e[t].call(a.exports,a,a.exports,o),a.l=!0,a.exports}o.m=e,o.c=l,o.d=function(e,t,a){o.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:a})},o.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},o.t=function(e,t){if(1&t&&(e=o(e)),8&t)return e;if(4&t&&"object"===typeof e&&e&&e.__esModule)return e;var a=Object.create(null);if(o.r(a),Object.defineProperty(a,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var l in e)o.d(a,l,function(t){return e[t]}.bind(null,l));return a},o.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return o.d(t,"a",t),t},o.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},o.p="";var n=window["webpackJsonp"]=window["webpackJsonp"]||[],r=n.push.bind(n);n.push=t,n=n.slice();for(var i=0;i<n.length;i++)t(n[i]);var b=r;d.push([0,"chunk-vendors"]),a()})({0:function(e,t,a){e.exports=a("56d7")},"0391":function(e,t,a){e.exports=a.p+"img/study.05e912dd.png"},"0f61":function(e,t,a){e.exports=a.p+"img/horizontally-vertically1.926e1b55.png"},"28fe":function(e,t,a){"use strict";a("d1ff")},"364d":function(e,t,a){"use strict";a("cd84")},"3cd1":function(e,t,a){e.exports=a.p+"img/horizontally-vertically3.e488edd2.png"},"56d7":function(e,t,a){"use strict";a.r(t);a("3bc8");var l=a("ee0f"),c=a.n(l),d=(a("737e"),a("7d11")),o=a.n(d),n=(a("1e7f"),a("d94e")),r=a.n(n),i=(a("3b10"),a("4445")),b=a.n(i),u=(a("a1a7"),a("9ebf")),p=a.n(u),v=(a("efe7"),a("c026")),f=a.n(v),O=(a("ab0d"),a("a2ec")),j=a.n(O),N=(a("884b"),a("0518")),s=a.n(N),V=(a("4af4"),a("44fb")),h=a.n(V),T=(a("e260"),a("e6cf"),a("cca6"),a("a79d"),a("7a23")),S={id:"app"};function m(e,t,a,l,c,d){var o=Object(T["resolveComponent"])("router-view");return Object(T["openBlock"])(),Object(T["createBlock"])("div",S,[Object(T["createVNode"])(o)])}var g={name:"App"};a("fd44");g.render=m;var x=g,C=a("6c02"),I=a("0391"),P=a.n(I),_=Object(T["withScopeId"])("data-v-2e56cff0");Object(T["pushScopeId"])("data-v-2e56cff0");var y={id:"hello"},w=Object(T["createVNode"])("div",{id:"hi"},[Object(T["createVNode"])("img",{alt:"Vue logo",src:P.a})],-1),k=Object(T["createVNode"])("h1",{id:"title"}," Welcome to My Front-end Study Notes",-1),B={id:"hi"},H=Object(T["createTextVNode"])("START");Object(T["popScopeId"])();var M=_((function(e,t,a,l,c,d){var o=Object(T["resolveComponent"])("el-button"),n=Object(T["resolveComponent"])("router-link");return Object(T["openBlock"])(),Object(T["createBlock"])("div",y,[w,k,Object(T["createVNode"])("div",B,[Object(T["createVNode"])(n,{to:"/home"},{default:_((function(){return[Object(T["createVNode"])(o,{round:""},{default:_((function(){return[H]})),_:1})]})),_:1})])])})),D={name:"HelloWorld",props:{}};a("c435");D.render=M,D.__scopeId="data-v-2e56cff0";var L=D,F=Object(T["withScopeId"])("data-v-cb08058e");Object(T["pushScopeId"])("data-v-cb08058e");var U=Object(T["createVNode"])("img",{src:P.a,alt:""},null,-1),A=Object(T["createVNode"])("span",null,"前端学习笔记",-1),E=Object(T["createVNode"])("i",{class:"el-icon-pear"},null,-1),R=Object(T["createVNode"])("span",null,"计算机网络",-1),q=Object(T["createTextVNode"])("应用层"),W=Object(T["createTextVNode"])("传输层"),X=Object(T["createTextVNode"])("网络层"),J=Object(T["createTextVNode"])("数据链路层"),z=Object(T["createTextVNode"])("物理层"),G=Object(T["createVNode"])("i",{class:"el-icon-grape"},null,-1),K=Object(T["createVNode"])("span",null,"HTML",-1),Y=Object(T["createTextVNode"])("总结"),Q=Object(T["createVNode"])("i",{class:"el-icon-orange"},null,-1),Z=Object(T["createVNode"])("span",null,"CSS",-1),$=Object(T["createTextVNode"])("总结"),ee=Object(T["createVNode"])("i",{class:"el-icon-cherry"},null,-1),te=Object(T["createVNode"])("span",null,"JavaScript",-1),ae=Object(T["createTextVNode"])("总结"),le=Object(T["createVNode"])("i",{class:"el-icon-apple"},null,-1),ce=Object(T["createVNode"])("span",null,"数据结构",-1),de=Object(T["createTextVNode"])("总结");Object(T["popScopeId"])();var oe=F((function(e,t,a,l,c,d){var o=Object(T["resolveComponent"])("el-header"),n=Object(T["resolveComponent"])("el-menu-item"),r=Object(T["resolveComponent"])("el-submenu"),i=Object(T["resolveComponent"])("el-menu"),b=Object(T["resolveComponent"])("el-aside"),u=Object(T["resolveComponent"])("router-view"),p=Object(T["resolveComponent"])("el-main"),v=Object(T["resolveComponent"])("el-container");return Object(T["openBlock"])(),Object(T["createBlock"])("div",null,[Object(T["createVNode"])(v,{class:"container"},{default:F((function(){return[Object(T["createVNode"])(o,null,{default:F((function(){return[U,A]})),_:1}),Object(T["createVNode"])(v,null,{default:F((function(){return[Object(T["createVNode"])(b,{width:c.isCollapse?"64px":"200px"},{default:F((function(){return[Object(T["createVNode"])("div",{class:"toggle-button",onClick:t[1]||(t[1]=function(){return d.toggleCollapse&&d.toggleCollapse.apply(d,arguments)})},"|||"),Object(T["createVNode"])(i,{"text-color":"#333","active-text-color":"red","unique-opened":!0,"collapse-transition":"false",collapse:c.isCollapse,router:!0},{default:F((function(){return[Object(T["createVNode"])(r,{index:"1"},{title:F((function(){return[E,R]})),default:F((function(){return[Object(T["createVNode"])(n,{index:"1-1"},{default:F((function(){return[q]})),_:1}),Object(T["createVNode"])(n,{index:"1-2"},{default:F((function(){return[W]})),_:1}),Object(T["createVNode"])(n,{index:"1-3"},{default:F((function(){return[X]})),_:1}),Object(T["createVNode"])(n,{index:"1-4"},{default:F((function(){return[J]})),_:1}),Object(T["createVNode"])(n,{index:"1-5"},{default:F((function(){return[z]})),_:1})]})),_:1}),Object(T["createVNode"])(r,{index:"2"},{title:F((function(){return[G,K]})),default:F((function(){return[Object(T["createVNode"])(n,{index:"2-1"},{default:F((function(){return[Y]})),_:1})]})),_:1}),Object(T["createVNode"])(r,{index:"3"},{title:F((function(){return[Q,Z]})),default:F((function(){return[Object(T["createVNode"])(n,{index:"3-1"},{default:F((function(){return[$]})),_:1})]})),_:1}),Object(T["createVNode"])(r,{index:"4"},{title:F((function(){return[ee,te]})),default:F((function(){return[Object(T["createVNode"])(n,{index:"4-1"},{default:F((function(){return[ae]})),_:1})]})),_:1}),Object(T["createVNode"])(r,{index:"5"},{title:F((function(){return[le,ce]})),default:F((function(){return[Object(T["createVNode"])(n,{index:"5-1"},{default:F((function(){return[de]})),_:1})]})),_:1})]})),_:1},8,["collapse"])]})),_:1},8,["width"]),Object(T["createVNode"])(p,null,{default:F((function(){return[Object(T["createVNode"])(u)]})),_:1})]})),_:1})]})),_:1})])})),ne={name:"home",props:{},data:function(){return{isCollapse:!1}},methods:{toggleCollapse:function(){this.isCollapse=!this.isCollapse}}};a("364d");ne.render=oe,ne.__scopeId="data-v-cb08058e";var re=ne,ie=Object(T["withScopeId"])("data-v-2309b75a");Object(T["pushScopeId"])("data-v-2309b75a");var be=Object(T["createStaticVNode"])('<h2 data-v-2309b75a>应用层</h2><p data-v-2309b75a>含义：应用层协议定义了应用进程间的交互和通信规则。</p><h3 data-v-2309b75a>HTTP协议</h3><p data-v-2309b75a>含义：HTTP是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。</p><p data-v-2309b75a>特点： <ol data-v-2309b75a><li data-v-2309b75a>HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。</li><li data-v-2309b75a>有会话的，可以使用cookies保存一小段数据。</li></ol></p><p data-v-2309b75a>连接模式： <ul data-v-2309b75a><li data-v-2309b75a>非持久连接：服务器必须为每一个请求的对象建立和维护一个全新的连接。</li><li data-v-2309b75a>持久连接：TCP 连接默认不关闭，可以被多个请求复用。</li></ul></p><h4 data-v-2309b75a>HTTP请求报文</h4><p data-v-2309b75a>HTTP请求报文含三部分：请求行、首部行、实体主体</p><p class="a" data-v-2309b75a>请求行包含：方法字段、URL字段和 HTTP版本字段</p>',9),ue=Object(T["createVNode"])("div",{class:"b"},[Object(T["createVNode"])("table",{class:"c",border:"1",cellspacing:"0",cellpadding:"5",width:"500",height:"220"},[Object(T["createVNode"])("thead",null,[Object(T["createVNode"])("tr",null,[Object(T["createVNode"])("th",null,"方法字段"),Object(T["createVNode"])("th",null,"含义")])]),Object(T["createVNode"])("tbody",null,[Object(T["createVNode"])("tr",null,[Object(T["createVNode"])("td",null,"GET"),Object(T["createVNode"])("td",null,"请求服务器发送某个资源，请求不含实体主体，是安全的，幂等的。")]),Object(T["createVNode"])("tr",null,[Object(T["createVNode"])("td",null,"POST"),Object(T["createVNode"])("td",null,"将实体提交到指定的资源，通常通过HTML表单发送，并返回服务器的修改结果。不安全，非幂等的。")]),Object(T["createVNode"])("tr",null,[Object(T["createVNode"])("td",null,"PUT"),Object(T["createVNode"])("td",null,"用请求有效载荷替换目标资源的所有当前表示。")]),Object(T["createVNode"])("tr",null,[Object(T["createVNode"])("td",null,"PATCH"),Object(T["createVNode"])("td",null,"用于对资源进行部分修改。")]),Object(T["createVNode"])("tr",null,[Object(T["createVNode"])("td",null,"CONNECT"),Object(T["createVNode"])("td",null,"建立一个由客户端到目标资源标识的服务器的隧道。")]),Object(T["createVNode"])("tr",null,[Object(T["createVNode"])("td",null,"HEAD"),Object(T["createVNode"])("td",null,"请求一个与GET请求的响应相同的响应，但没有响应体。")])])])],-1),pe=Object(T["createVNode"])("h4",null,"HTTP响应报文",-1),ve=Object(T["createVNode"])("p",null,"HTTP响应报文含三部分：状态行、首部行、实体主体",-1),fe=Object(T["createVNode"])("p",{class:"c"},"状态行包含：HTTP版本字段、状态码、相应的状态信息",-1),Oe=Object(T["createVNode"])("ul",{class:"d"},[Object(T["createVNode"])("li",null,"1XX:代表服务器接收到请求"),Object(T["createVNode"])("li",null,"2XX:代表成功"),Object(T["createVNode"])("li",null,"3XX:代表重定向"),Object(T["createVNode"])("li",null,"4XX:代表客户端错误"),Object(T["createVNode"])("li",null,"5XX:代表服务器端错误")],-1),je=Object(T["createVNode"])("div",{class:"e"},[Object(T["createVNode"])("table",{class:"c",border:"1",cellspacing:"0",cellpadding:"5",width:"500",height:"220"},[Object(T["createVNode"])("thead",null,[Object(T["createVNode"])("tr",null,[Object(T["createVNode"])("th",null,"状态码"),Object(T["createVNode"])("th",null,"英文名称"),Object(T["createVNode"])("th",null,"中文描述")])]),Object(T["createVNode"])("tbody",null,[Object(T["createVNode"])("tr",null,[Object(T["createVNode"])("td",null,"100"),Object(T["createVNode"])("td",null,"continue"),Object(T["createVNode"])("td",null,"一切正常，服务器可以继续发送请求。")]),Object(T["createVNode"])("tr",null,[Object(T["createVNode"])("td",null,"200"),Object(T["createVNode"])("td",null,"OK"),Object(T["createVNode"])("td",null,"请求成功")]),Object(T["createVNode"])("tr",null,[Object(T["createVNode"])("td",null,"202"),Object(T["createVNode"])("td",null,"Accepted"),Object(T["createVNode"])("td",null,"已经接受请求，但未响应。")]),Object(T["createVNode"])("tr",null,[Object(T["createVNode"])("td",null,"204"),Object(T["createVNode"])("td",null,"No Content"),Object(T["createVNode"])("td",null,"服务器成功处理，但未返回实体主体。")]),Object(T["createVNode"])("tr",null,[Object(T["createVNode"])("td",null,"301"),Object(T["createVNode"])("td",null,"Moved Permanently"),Object(T["createVNode"])("td",null,"永久移动。请求的资源已被永久的移动到新URI，今后任何新的请求都应使用新的URI代替。")]),Object(T["createVNode"])("tr",null,[Object(T["createVNode"])("td",null,"302"),Object(T["createVNode"])("td",null,"Found"),Object(T["createVNode"])("td",null,"临时移动。请求的资源只是临时被移动。客户端之后的请求应继续使用原有URI。")]),Object(T["createVNode"])("tr",null,[Object(T["createVNode"])("td",null,"304"),Object(T["createVNode"])("td",null,"Not Modified"),Object(T["createVNode"])("td",null,"所请求的资源未修改，服务器不会返回任何资源，但客户端可以使用缓存中的内容。")]),Object(T["createVNode"])("tr",null,[Object(T["createVNode"])("td",null,"204"),Object(T["createVNode"])("td",null,"No Content"),Object(T["createVNode"])("td",null,"服务器成功处理，但未返回实体主体。")]),Object(T["createVNode"])("tr",null,[Object(T["createVNode"])("td",null,"307"),Object(T["createVNode"])("td",null,"Temporary Redirect"),Object(T["createVNode"])("td",null,"临时重定向。与302类似。但307可以确保请求方法和实体主体不变。")]),Object(T["createVNode"])("tr",null,[Object(T["createVNode"])("td",null,"308"),Object(T["createVNode"])("td",null,"Permanent Redirect"),Object(T["createVNode"])("td",null,"永久重定向。与301类似。但308可以确保请求方法和实体主体不变。")]),Object(T["createVNode"])("tr",null,[Object(T["createVNode"])("td",null,"400"),Object(T["createVNode"])("td",null,"Bad Request"),Object(T["createVNode"])("td",null,"客户端请求的语法错误，服务器无法理解。")]),Object(T["createVNode"])("tr",null,[Object(T["createVNode"])("td",null,"404"),Object(T["createVNode"])("td",null,"Not Found"),Object(T["createVNode"])("td",null,"服务器未找到请求的资源。")]),Object(T["createVNode"])("tr",null,[Object(T["createVNode"])("td",null,"500"),Object(T["createVNode"])("td",null,"Internal Server Error"),Object(T["createVNode"])("td",null,"客服务器内部出错。")]),Object(T["createVNode"])("tr",null,[Object(T["createVNode"])("td",null,"503"),Object(T["createVNode"])("td",null,"Service Unavailable "),Object(T["createVNode"])("td",null,"由于超载或系统维护，服务器暂时的无法处理客户端的请求。（即服务器未准备好处理请求）")])])])],-1),Ne=Object(T["createStaticVNode"])("<h4 data-v-2309b75a>HTTP/1.0</h4><p data-v-2309b75a>特点：采用非持久连接，服务器必须为每次请求的对象建立和维护一个全新的连接。</p><h4 data-v-2309b75a>HTTP/1.1</h4><p data-v-2309b75a>特点：采用持久连接，多个请求可以复用同一个 TCP 连接。</p><p data-v-2309b75a>缺点：数据请求的通信次序 是固定的。服务器只有处理完一个请求的响应后，才会进行下一个请求的处理，如果前面请求的响应特别慢的话，就会造成许 多请求排队等待的情况，这种情况被称为“队头堵塞”。</p><p data-v-2309b75a>解决办法： <ul data-v-2309b75a><li data-v-2309b75a>减少请求数</li><li data-v-2309b75a>同时打开多个持久连接</li></ul></p><h4 data-v-2309b75a>HTTP/2</h4><p data-v-2309b75a>目的：主要解决 HTTP/1.1 效率不高的问题。</p><p data-v-2309b75a>新特性：</p><ul data-v-2309b75a><li data-v-2309b75a>二进制协议 <p data-v-2309b75a>在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为&quot;帧&quot;，可以分为头信息帧和数据帧。它是实现多路复用的基础。</p></li><li data-v-2309b75a>多路复用 <p data-v-2309b75a>在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了&quot;队头堵塞&quot;的问题。</p></li><li data-v-2309b75a>数据流 <p data-v-2309b75a>将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流 ID ，用来区分它属于哪个数据流。</p></li><li data-v-2309b75a>头信息压缩 <p data-v-2309b75a>一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面， 客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。</p></li><li data-v-2309b75a>服务器推送 <p data-v-2309b75a>允许服务器未经请求，主动向客户端发送静态资源资源。</p></li></ul><h3 data-v-2309b75a>HTTPS协议</h3><p data-v-2309b75a>含义：HTTPS 指的是超文本传输安全协议，HTTPS 是基于 HTTP 协议的，不过它会使用 TLS/SSL 来对数据加密。使用 TLS/ SSL 协议，所有的信息都是加密的，第三方没有办法窃听。并且它提供了一种校验机制，信息一旦被篡改，通信的双方会立刻发现。它还配备了身份证书，防止身份被冒充的情况出现。</p><p data-v-2309b75a>TLS握手过程：</p><ul data-v-2309b75a><li data-v-2309b75a>客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。</li><li data-v-2309b75a>服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。</li><li data-v-2309b75a>客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服务器。然后服务器使用自己的私钥，来解密客户端发送过来的随机数。</li><li data-v-2309b75a>客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。</li></ul><h3 data-v-2309b75a>DNS协议</h3><p data-v-2309b75a>含义：DNS 协议提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。</p><p data-v-2309b75a>递归查询和迭代查询：</p><ul data-v-2309b75a><li data-v-2309b75a>我们向本地 DNS 服务器发送请求的方式就是递归查询。</li><li data-v-2309b75a>本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程。</li></ul><p data-v-2309b75a>DNS 缓存：</p><p data-v-2309b75a>含义：当某个 DNS 服务器接收到一个 DNS 回答后，它能够将回答中的信息缓存在本地存储器中。</p>",20);Object(T["popScopeId"])();var se=ie((function(e,t,a,l,c,d){return Object(T["openBlock"])(),Object(T["createBlock"])("div",null,[be,ue,pe,ve,fe,Oe,je,Ne])})),Ve={name:"application",props:{}};a("88a7");Ve.render=se,Ve.__scopeId="data-v-2309b75a";var he=Ve,Te=Object(T["withScopeId"])("data-v-11bb2285");Object(T["pushScopeId"])("data-v-11bb2285");var Se=Object(T["createStaticVNode"])("<h2 data-v-11bb2285>传输层</h2><p data-v-11bb2285>含义：传输层协议主要是为不同主机上的不同进程间提供了逻辑通信的功能。</p><h3 data-v-11bb2285>多路复用和多路分解：</h3><ul data-v-11bb2285><li data-v-11bb2285>一个信道同时传输多路信号是多路复用。</li><li data-v-11bb2285>将多路信号交付给对应的接收端是多路分解。</li></ul><p data-v-11bb2285>无连接的多路复用和多路分解指的是 UDP 套接字的分配过程，一个 UDP 套接字由一个二元组来标识，这个二元组包含了一个目的地址和一个目的端口号。</p><p data-v-11bb2285>面向连接的多路复用和多路分解指的是 TCP 套接字的分配过程，一个 TCP 套接字由一个四元组来标识，这个四元组包含了源 IP 地址、源端口号、目的地址和目的端口号。</p><h3 data-v-11bb2285>UDP协议</h3><p data-v-11bb2285>含义：UDP 是一种无连接的，不可靠的传输层协议。</p><p data-v-11bb2285>特点：</p><ul data-v-11bb2285><li data-v-11bb2285>使用 UDP 时，在发送报文段之前，通信双方没有握手的过程，因此 UDP 被称为是无连接的传输层协议。</li><li data-v-11bb2285>UDP 协议不保证数据的可靠交付。</li></ul><p data-v-11bb2285>UDP 报文段结构：</p><p data-v-11bb2285>UDP 报文段由首部和应用数据组成。报文段首部包含四个字段，分别是源端口号、目的端口号、长度和检验和。</p><h3 data-v-11bb2285>TCP协议</h3><p data-v-11bb2285>含义：TCP 协议是面向连接的，提供可靠数据传输服务的传输层协议。</p><p data-v-11bb2285>特点：</p><ul data-v-11bb2285><li data-v-11bb2285>TCP 协议是面向连接的，在通信双方进行通信前，需要通过三次握手建立连接。</li><li data-v-11bb2285>TCP 协议通过序号、确认号、定时重传、检验和等机制，来提供可靠的数据传输服务。</li><li data-v-11bb2285>TCP 提供了流量控制机制和拥塞控制机制。</li></ul><h3 data-v-11bb2285>TCP三次握手过程</h3><ol data-v-11bb2285><li data-v-11bb2285>客户端向服务器发送一个 SYN 连接请求报文段以及客户端数据的初始序号。</li><li data-v-11bb2285>服务器端接收到客户端发送的 SYN 连接请求报文段后，向客户端发送 SYN ACK 报文段以及服务器端数据的初始序号。</li><li data-v-11bb2285>客户端接收到服务器的肯定应答后，它也会为这次 TCP 连接分配缓存和变量，同时向服务器端发送一个对服务器端的报文段的确认。</li></ol><h3 data-v-11bb2285>TCP四次挥手过程</h3><ol data-v-11bb2285><li data-v-11bb2285>客户端认为没有数据要再发送给服务器端，它就向服务器发送一个 FIN 报文段，申请断开客户端到服务器端的连接。发送后客户端进入 FIN_WAIT_1 状态。</li><li data-v-11bb2285>服务器端接收到客户端释放连接的请求后，向客户端发送一个确认报文段，表示已经接收到了客户端释放连接的请求，以后不再接收客户端发送过来的数据。但是因为连接是全双工的，所以此时，服务器端还可以向客户端发送数据。服务器端进入 CLOSE_WAIT 状态。客户端收到确认后，进入 FIN_WAIT_2 状态。</li><li data-v-11bb2285>服务器端发送完所有数据后，向客户端发送 FIN 报文段，申请断开服务器端到客户端的连接。发送后进入 LAS T_ACK 状态。</li><li data-v-11bb2285>客户端接收到 FIN 请求后，向服务器端发送一个确认应答，并进入 TIME_WAIT 阶段。该阶段会持续一段时间， 这个时间为报文段在网络中的最大生存时间，如果该时间内服务端没有重发请求的话，客户端进入 CLOSED 的状态。如果收到服务器的重发请求就重新发送确认报文段。服务器端收到客户端的确认报文段后就进入 CLOSED 状态，这样全双工的连接就被释放了。</li></ol><h3 data-v-11bb2285>TCP的可靠运输机制</h3><ul data-v-11bb2285><li data-v-11bb2285>TCP 的可靠运输机制是基于连续 ARQ 协议和滑动窗口协议的。</li><li data-v-11bb2285>TCP就是通过调整发送窗口的大小来控制发送速率，发送窗口的大小根据网络的拥塞程度动态变化。</li><li data-v-11bb2285>接收方使用的是累计确认的机制，对于所有按序到达的报文段，接收方返回一个报文段的肯定回答。如果收到了一个乱序的报文 段，那么接方会直接丢弃，并返回一个最近的按序到达的报文段的肯定回答。</li></ul><h3 data-v-11bb2285>TCP流量控制机制</h3><p data-v-11bb2285>目的：控制发送方的发送速率，保证接收方来得及接收。</p><p data-v-11bb2285>方法：接收方主要是通过接收窗口来告诉发送方自己所能接收的大小，发送方根据 接收方的接收窗口的大小来调整发送窗口的大小，以此来达到控制发送速率的目的。</p><h3 data-v-11bb2285>TCP拥塞控制机制</h3><p data-v-11bb2285>目的：根据网络中的拥塞情况来控制发送方数据的发送速率。一方面是为了避免继续增加网络中的拥塞程度，另一方面也是为了避免网络拥塞可能造成的报文段丢失。</p><p data-v-11bb2285>TCP 的拥塞控制主要使用了四个机制: <ul data-v-11bb2285><li data-v-11bb2285>慢启动:在发送方刚开始发送数据的时候，并不知道网络中的拥塞程度，所以先以较低的速率发送，进行试探 ，每次收到一个确认报文，就将发动窗口的长度加一，这样每个 RTT 时间后，发送窗口的长度就会加倍。当发送窗口的大小达到一个阈值的时候就进入拥塞避免算法。</li><li data-v-11bb2285>拥塞避免:为了避免可能发生的拥塞，将发送窗口的大小由每过一个 RTT 增长一倍，变为每过一个 RTT ，长度只加一。 这样将窗口的增长速率由指数增长，变为加法线性增长。</li><li data-v-11bb2285>快速重传:当发送方收到三个冗余的确认应答时，因为 TCP 使用的是累计确认的机制，所以很有可能是发生了报文段的 丢失，因此采用立即重传的机制，在定时器结束前发送所有已发送但还未接收到确认应答的报文段。</li><li data-v-11bb2285>快速恢复:因为网络中可能已经出现了拥塞情况，所以会将慢启动的阀值减小为原来的一半，然后将拥 塞窗口的值置为减半后的阀值，然后开始执行拥塞避免算法，使得拥塞窗口缓慢地加性增大。简单来理解就是，乘性减，加性增。</li></ul></p>",28);Object(T["popScopeId"])();var me=Te((function(e,t,a,l,c,d){return Object(T["openBlock"])(),Object(T["createBlock"])("div",null,[Se])})),ge={name:"transport",props:{}};ge.render=me,ge.__scopeId="data-v-11bb2285";var xe=ge,Ce=Object(T["withScopeId"])("data-v-e11d0800");Object(T["pushScopeId"])("data-v-e11d0800");var Ie=Object(T["createVNode"])("h2",null,"网络层",-1),Pe=Object(T["createVNode"])("p",null,"含义：网络层协议主要实现了不同主机间的逻辑通信功能。",-1);Object(T["popScopeId"])();var _e=Ce((function(e,t,a,l,c,d){return Object(T["openBlock"])(),Object(T["createBlock"])("div",null,[Ie,Pe])})),ye={name:"network",props:{}};ye.render=_e,ye.__scopeId="data-v-e11d0800";var we=ye,ke=Object(T["withScopeId"])("data-v-80f5a64c");Object(T["pushScopeId"])("data-v-80f5a64c");var Be=Object(T["createVNode"])("h2",null,"数据链路层",-1),He=Object(T["createVNode"])("p",null,"含义：数据链路层在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是将源自物理层来的数据可靠地传输到相邻节点的目标机网络层。",-1);Object(T["popScopeId"])();var Me=ke((function(e,t,a,l,c,d){return Object(T["openBlock"])(),Object(T["createBlock"])("div",null,[Be,He])})),De={name:"data_link",props:{}};De.render=Me,De.__scopeId="data-v-80f5a64c";var Le=De,Fe=Object(T["withScopeId"])("data-v-4b31c57c");Object(T["pushScopeId"])("data-v-4b31c57c");var Ue=Object(T["createVNode"])("h2",null,"物理层",-1),Ae=Object(T["createVNode"])("p",null,"含义：物理层为设备之间的数据通信提供传输媒体及互连设备，为数据传输提供可靠的环境。",-1);Object(T["popScopeId"])();var Ee=Fe((function(e,t,a,l,c,d){return Object(T["openBlock"])(),Object(T["createBlock"])("div",null,[Ue,Ae])})),Re={name:"physical",props:{}};Re.render=Ee,Re.__scopeId="data-v-4b31c57c";var qe=Re,We=Object(T["withScopeId"])("data-v-e0cf6df4");Object(T["pushScopeId"])("data-v-e0cf6df4");var Xe=Object(T["createStaticVNode"])("<h2 data-v-e0cf6df4>HTML</h2><p data-v-e0cf6df4>含义：超文本标记语言,用于定义网页结构。</p><h3 data-v-e0cf6df4>HTML标签和元素</h3><p data-v-e0cf6df4>HTML 标记标签通常被称为 HTML 标签 (HTML tag)。</p><ul data-v-e0cf6df4><li data-v-e0cf6df4>HTML 标签是由尖括号包围的关键词。</li><li data-v-e0cf6df4>HTML 标签通常是成对出现的。</li><li data-v-e0cf6df4>标签对中的第一个标签是开始标签，第二个标签是结束标签。</li></ul><p data-v-e0cf6df4>&quot;HTML 标签&quot; 和 &quot;HTML 元素&quot; 通常都是描述同样的意思.但是严格来讲, 一个 HTML 元素包含了开始标签与结束标签。</p><h3 data-v-e0cf6df4>Web浏览器</h3><p data-v-e0cf6df4>Web浏览器（如谷歌浏览器，Internet Explorer，Firefox，Safari）是用于读取HTML文件，并将其作为网页显示。</p><h3 data-v-e0cf6df4>行内元素和块级元素</h3><p data-v-e0cf6df4>行内元素：只占内容部分，大部分行内元素的宽高不可设置。</p><p data-v-e0cf6df4>常见的行内元素：a 、span 、 img 、button 、 input 、 label 、 select 、 textarea</p><p data-v-e0cf6df4>块级元素：独占一行，宽高、内外边距都可以设置。</p><p data-v-e0cf6df4>常见的块级元素：div 、 ul 、 ol 、li 、 dl 、 dt 、 dd 、 h1 、h2 、 h3 、 h4 、 h5 、 h6 、 p</p><h3 data-v-e0cf6df4>进程和线程</h3><p data-v-e0cf6df4>进程：最小的资源管理单元</p><p data-v-e0cf6df4>线程：最小的执行单元</p><p data-v-e0cf6df4>浏览器本身就是多进程的，包括：</p><ul data-v-e0cf6df4><li data-v-e0cf6df4>Browser进程：浏览器主进程</li><li data-v-e0cf6df4>Render进程：渲染进程，也叫内核</li><li data-v-e0cf6df4>GPU进程：3D绘制</li><li data-v-e0cf6df4>第三方插件进程</li></ul><p data-v-e0cf6df4>Render进程包括多个线程：</p><ul data-v-e0cf6df4><li data-v-e0cf6df4>GUI线程</li><li data-v-e0cf6df4>JS引擎线程</li><li data-v-e0cf6df4>事件触发线程</li><li data-v-e0cf6df4>定时器线程</li><li data-v-e0cf6df4>异步http请求线程</li></ul><h3 data-v-e0cf6df4>浏览器的渲染原理</h3><ol data-v-e0cf6df4><li data-v-e0cf6df4>解析文档，构建DOM树</li><li data-v-e0cf6df4>解析CSS，构建CSSOM规则树</li><li data-v-e0cf6df4>根据DOM树和CSSOM规则树，生成渲染树，通过渲染树进行布局，确定各个节点在页面上的位置和大小。</li><li data-v-e0cf6df4>最后用paint方法对内容进行绘制。</li></ol><h3 data-v-e0cf6df4>浏览器端的存储技术</h3><ul data-v-e0cf6df4><li data-v-e0cf6df4>cookie:由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。</li><li data-v-e0cf6df4>sessionStorage: 是 html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保存的数据。它一般能够存储 5M 或者更大的数据，它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源页面所访问共享。</li><li data-v-e0cf6df4> localStorage: 也是 html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5M 或者更大的数据。它和 sessionStorage 不同的是，除非手动删除它，否则它不会失效，并且 localStorage 也只能被同源页面所访问共享。</li></ul>",24);Object(T["popScopeId"])();var Je=We((function(e,t,a,l,c,d){return Object(T["openBlock"])(),Object(T["createBlock"])("div",null,[Xe])})),ze={name:"conclusion_html",props:{}};ze.render=Je,ze.__scopeId="data-v-e0cf6df4";var Ge=ze,Ke=a("f3ea"),Ye=a.n(Ke),Qe=a("0f61"),Ze=a.n(Qe),$e=a("c48d"),et=a.n($e),tt=a("3cd1"),at=a.n(tt),lt=a("c131"),ct=a.n(lt),dt=a("7849"),ot=a.n(dt),nt=Object(T["withScopeId"])("data-v-0c517679");Object(T["pushScopeId"])("data-v-0c517679");var rt=Object(T["createVNode"])("h2",null,"CSS",-1),it=Object(T["createVNode"])("p",null,"含义：层叠样式表,用于定义网页样式。",-1),bt=Object(T["createVNode"])("h3",null,"盒模型",-1),ut=Object(T["createVNode"])("p",null,"盒模型分为：内容（content）、填充（padding）、边界（margin）、边框（border）四个部分。",-1),pt=Object(T["createVNode"])("p",null,"两种盒子模型：IE盒模型（border-box）、W3C标准盒模型（content-box）。",-1),vt=Object(T["createVNode"])("p",{class:"a"},"区别：IE盒模型：属性width，height包含content、border和padding。W3C标准盒模型：属性width，height只包含内容content。",-1),ft=Object(T["createVNode"])("p",null,"通过 box-sizing 属性可改变盒模型。",-1),Ot=Object(T["createVNode"])("h3",null,"选择器",-1),jt=Object(T["createVNode"])("p",null,"伪类一般匹配的是元素的一些特殊状态，如hover、link等，而伪元素一般匹配的特殊的位置，比如after、before等。",-1),Nt=Object(T["createVNode"])("p",{class:"b"},"注意：权重叠加，不能进位，继承的权重为0。",-1),st=Object(T["createVNode"])("h3",null,"display的值",-1),Vt=Object(T["createVNode"])("ul",null,[Object(T["createVNode"])("li",null,"block:块级元素，独占一行，可设置宽高。"),Object(T["createVNode"])("li",null,"inline:行内元素，只占内容部分，大部分不可设置宽高，同行显示。"),Object(T["createVNode"])("li",null,"inline-block：行内块元素，可以一行放多个，宽高可设置"),Object(T["createVNode"])("li",null,"none：不显示"),Object(T["createVNode"])("li",null,"inherit：继承父元素display属性的值"),Object(T["createVNode"])("li",null,"flex:弹性布局")],-1),ht=Object(T["createVNode"])("h3",null,"position的值",-1),Tt=Object(T["createVNode"])("ul",null,[Object(T["createVNode"])("li",null,"absolute：绝对定位，相对父级位置移动，不占位置"),Object(T["createVNode"])("li",null,"relative：相对定位，相对自身位置移动，占有位置"),Object(T["createVNode"])("li",null,"fixed:固定，相对浏览器位置移动，不占有位置。"),Object(T["createVNode"])("li",null,"static：默认值，没有定位，元素出现在正常的流中。")],-1),St=Object(T["createVNode"])("h3",null,"居中方法",-1),mt=Object(T["createVNode"])("p",null,"水平居中：",-1),gt=Object(T["createVNode"])("img",{src:Ye.a,alt:"",width:"200px"},null,-1),xt=Object(T["createVNode"])("p",null,"水平垂直居中：",-1),Ct=Object(T["createVNode"])("p",null,"绝对定位3种：",-1),It=Object(T["createVNode"])("img",{class:"c",src:Ze.a,alt:""},null,-1),Pt=Object(T["createVNode"])("img",{class:"c",src:et.a,alt:""},null,-1),_t=Object(T["createVNode"])("img",{class:"c",src:at.a,alt:""},null,-1),yt=Object(T["createVNode"])("p",null,"flex布局1种：",-1),wt=Object(T["createVNode"])("img",{class:"c",src:ct.a,alt:""},null,-1),kt=Object(T["createVNode"])("h3",null,"Flex弹性布局",-1),Bt=Object(T["createVNode"])("p",null,"弹性布局分为两部分：容器和项目。",-1),Ht=Object(T["createVNode"])("p",null,[Object(T["createTextVNode"])("以下6个属性设置在容器上: "),Object(T["createVNode"])("ul",null,[Object(T["createVNode"])("li",null,"flex-direction属性决定主轴的方向（即项目的排列方向）。"),Object(T["createVNode"])("li",null,"flex-wrap属性定义，如果一条轴线排不下，如何换行。"),Object(T["createVNode"])("li",null,"flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。"),Object(T["createVNode"])("li",null,"justify-content属性定义了项目在主轴上的对齐方式。"),Object(T["createVNode"])("li",null,"align-items属性定义项目在交叉轴上如何对齐。"),Object(T["createVNode"])("li",null,"align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。")])],-1),Mt=Object(T["createVNode"])("p",null,[Object(T["createTextVNode"])("以下6个属性设置在项目上: "),Object(T["createVNode"])("ul",null,[Object(T["createVNode"])("li",null,"order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。"),Object(T["createVNode"])("li",null,"flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。"),Object(T["createVNode"])("li",null,"flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。"),Object(T["createVNode"])("li",null,"flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。"),Object(T["createVNode"])("li",null,"flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。"),Object(T["createVNode"])("li",null,"align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。")])],-1),Dt=Object(T["createVNode"])("p",null,"实现三栏布局",-1),Lt=Object(T["createVNode"])("img",{class:"c",src:ot.a,alt:""},null,-1),Ft=Object(T["createVNode"])("h3",null,"BFC块级格式化上下文",-1),Ut=Object(T["createVNode"])("p",null,"含义：BFC指的是块级格式化上下文，一个元素形成了BFC之后，那么它内部元素产生的布局不会影响到外部元素，外部元素的布局也不会影响到BFC中的内部元素。一个BFC就像是一个隔离区域，和其他区域互不影响。",-1),At=Object(T["createVNode"])("p",null,"如何创建BFC：一般来说根元素是一个BFC区域，浮动和绝对定位的元素也会形成BFC，display属性的值为inline-block、flex这些属性时也会创建BFC。还有就是元素的overflow的值不为visible时都会创建BFC。",-1),Et=Object(T["createVNode"])("p",null,"作用：清除浮动，防止margin重叠。",-1),Rt=Object(T["createVNode"])("h3",null,"清除浮动",-1),qt=Object(T["createVNode"])("p",null,"目的：为了解决父级元素因为子级元素浮动而引起的内部高度为0的问题。",-1),Wt=Object(T["createVNode"])("p",null,[Object(T["createTextVNode"])("方法： "),Object(T["createVNode"])("ul",null,[Object(T["createVNode"])("li",null,"使用clear属性清除浮动。"),Object(T["createVNode"])("li",null,"使用BFC块级格式化上下文来清除浮动。"),Object(T["createVNode"])("li",null,"使用伪元素的方式清除浮动。")])],-1),Xt=Object(T["createVNode"])("h3",null,"移动端的三个viewport",-1),Jt=Object(T["createVNode"])("p",null,"layout viewport：移动设备通过滚动条或者缩放可以查看整个页面。",-1),zt=Object(T["createVNode"])("p",null,"visual viewport：移动设备上可见的区域的大小。",-1),Gt=Object(T["createVNode"])("p",null,"ideal viewport：通过修改布局视口的大小，让它等于设备的宽度。",-1),Kt=Object(T["createVNode"])("h3",null,"常见的元素隐藏方式",-1),Yt=Object(T["createVNode"])("ul",null,[Object(T["createVNode"])("li",null,"使用 display:none;隐藏元素，渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。"),Object(T["createVNode"])("li",null,"使用 visibility:hidden;隐藏元素。元素在页面中仍占据空间，但是不会响应绑定的监听事件。"),Object(T["createVNode"])("li",null,"使用 opacity:0;将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。"),Object(T["createVNode"])("li",null,"通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。"),Object(T["createVNode"])("li",null,"通过 z-index 负值，来使其他元素遮盖住该元素，以此来实现隐藏。"),Object(T["createVNode"])("li",null,"通过 transform:scale(0,0)来将元素缩放为 0，以此来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。")],-1);Object(T["popScopeId"])();var Qt=nt((function(e,t,a,l,c,d){return Object(T["openBlock"])(),Object(T["createBlock"])("div",null,[rt,it,bt,ut,pt,vt,ft,Ot,jt,Object(T["createVNode"])("p",{textContent:Object(T["toDisplayString"])(c.content1)},null,8,["textContent"]),Nt,st,Vt,ht,Tt,St,mt,gt,xt,Ct,It,Pt,_t,yt,wt,kt,Bt,Ht,Mt,Dt,Lt,Ft,Ut,At,Et,Rt,qt,Wt,Xt,Jt,zt,Gt,Kt,Yt])})),Zt={name:"conclusion_html",props:{},data:function(){return{content1:"优先级：通配符选择器 < 元素、伪元素(0001) < 类、伪类选择器(0010) < ID选择器(0100) < 行内样式(1000) < ！important"}}};a("28fe");Zt.render=Qt,Zt.__scopeId="data-v-0c517679";var $t=Zt,ea=Object(T["withScopeId"])("data-v-21d061f1");Object(T["pushScopeId"])("data-v-21d061f1");var ta=Object(T["createVNode"])("h2",null,"JavaScript",-1),aa=Object(T["createStaticVNode"])('<h3 data-v-21d061f1>JS数据类型</h3><ul data-v-21d061f1><li data-v-21d061f1>基本数据类型: Undefined、Null、Boolean、Number、String、Symbol</li><li data-v-21d061f1>复杂数据类型: Object （Array、Date）</li></ul><p data-v-21d061f1>区别：</p><p class="a" data-v-21d061f1>基本数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</p><h3 data-v-21d061f1>堆和栈</h3><ul data-v-21d061f1><li data-v-21d061f1>在数据结构中，栈中数据的存取方式为先进后出。而堆是一个优先队列，是按优先级来进行排序的。</li><li data-v-21d061f1>在操作系统中，内存被分为栈区和堆区。基本数据类型直接存储在栈中，复杂数据类型存储在堆中。</li></ul><h3 data-v-21d061f1>内部属性 [[Class]] </h3><p data-v-21d061f1>所有 typeof 返回值为 &quot;object&quot; 的对象（如数组）都包含一个内部属性 [[Class]]（我们可以把它看作一个内部的分类，而非传统的面向对象意义上的类）。这个属性无法直接访问，一般通过 Object.prototype.toString(..) 来查看。</p><h3 data-v-21d061f1>JS创建对象的方式</h3><p data-v-21d061f1>我们一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。我了解到的创建大量对象的方式有：</p><ul data-v-21d061f1><li data-v-21d061f1>工厂模式:工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它不能识别特定类型。</li><li data-v-21d061f1>构造函数模式：用this创建属性和方法，能表示特定类型，但方法会被重复创建。</li><li data-v-21d061f1>原型模式:在函数的prototype属性上创建对象的属性和方法。</li><li data-v-21d061f1>组合模式：通过构造函数初始化对象的属性，通过原型实现方法的复用。</li><li data-v-21d061f1>类</li></ul><h3 data-v-21d061f1>预解析和执行</h3><p data-v-21d061f1>在预解析阶段，会创建执行上下文，执行上下文分为： <ul data-v-21d061f1><li data-v-21d061f1>全局执行上下文</li><li data-v-21d061f1>函数执行上下文</li><li data-v-21d061f1>Eval执行上下文</li></ul></p><p data-v-21d061f1>一个执行上下文含： <ul data-v-21d061f1><li data-v-21d061f1>变量对象：用来存放函数和变量</li><li data-v-21d061f1>作用域链：各级执行上下文的变量对象组成的链表</li><li data-v-21d061f1>this</li></ul></p><p data-v-21d061f1>预解析阶段，变量对象含： <ul data-v-21d061f1><li data-v-21d061f1>根据函数参数创建的arguments对象</li><li data-v-21d061f1>寻找函数声明，若有，则将函数声明和引用存入变量对象。</li><li data-v-21d061f1>寻找变量声明，若有，则将变量名存入变量对象，并初始化undefined。</li></ul></p><h3 data-v-21d061f1>this指向</h3><ul data-v-21d061f1><li data-v-21d061f1>直接作为函数来调用时，this 指向全局对象。</li><li data-v-21d061f1>作为一个对象的方法来调用时，this 指向这个对象。</li><li data-v-21d061f1>apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。</li><li data-v-21d061f1>用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。</li></ul><p data-v-21d061f1>大多数情况下，this指向最后调用它的对象，箭头函数没有自己的this指向，它继承上一级作用域的this指向。</p><h3 data-v-21d061f1>闭包</h3><p data-v-21d061f1>含义：函数和函数可以访问的变量对象的总和。</p><p data-v-21d061f1>从理论上说，JS中所有的函数都是闭包。在实际应用中，通常在函数的内部再创建一个函数，那么创建的函数就可以访问当前函数作用域中的变量对象，此时内部函数和外部函数的变量对象就形成了闭包。</p><p data-v-21d061f1>作用： <ul data-v-21d061f1><li data-v-21d061f1>通过使用闭包，可以从函数外部调用闭包函数从而访问函数内部的变量。</li><li data-v-21d061f1>闭包也可以让已经结束运行的函数的变量对象保留下来不被垃圾回收机制回收。</li></ul></p><h3 data-v-21d061f1>new操作符</h3><p data-v-21d061f1>作用： <ul data-v-21d061f1><li data-v-21d061f1>首先创建了一个新的空对象</li><li data-v-21d061f1>设置原型，将对象的原型设置为函数的 prototype 对象。</li><li data-v-21d061f1>让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）。</li><li data-v-21d061f1>判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</li></ul></p><h3 data-v-21d061f1>DOM和BOM</h3><p data-v-21d061f1>DOM 指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。</p><p data-v-21d061f1>BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM的核心是 window。</p><h3 data-v-21d061f1>事件</h3><p data-v-21d061f1>含义：事件是用户操作网页时发生的交互动作，比如 click/move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。</p><p data-v-21d061f1>事件处理机制： <ul data-v-21d061f1><li data-v-21d061f1>事件冒泡</li><li data-v-21d061f1>事件捕获</li></ul></p><p data-v-21d061f1>阻止冒泡方法：event.stopPropagation() 或者 event.cancelBubble = true。</p><p data-v-21d061f1>三种事件模型： <ul data-v-21d061f1><li data-v-21d061f1>DOM0级：这种模型不会传播。</li><li data-v-21d061f1>DOM1级：在该事件模型中，一次事件共有两个过程，事件目标阶段和事件冒泡阶段。事件目标阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。</li><li data-v-21d061f1>DOM2级：在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。</li></ul></p>',32);Object(T["popScopeId"])();var la=ea((function(e,t,a,l,c,d){return Object(T["openBlock"])(),Object(T["createBlock"])("div",null,[ta,Object(T["createVNode"])("p",{innerHTML:c.content1},null,8,["innerHTML"]),aa])})),ca={name:"conclusion_js",props:{},data:function(){return{content1:"<p>含义：JavaScript 是一种轻量级的编程语言,用于实现网页间的交互。</p>"}}};a("d09a");ca.render=la,ca.__scopeId="data-v-21d061f1";var da=ca,oa=[{path:"/",component:L},{path:"/home",component:re,children:[{path:"/1-1",component:he},{path:"/1-2",component:xe},{path:"/1-3",component:we},{path:"/1-4",component:Le},{path:"/1-5",component:qe},{path:"/2-1",component:Ge},{path:"/3-1",component:$t},{path:"/4-1",component:da}]}],na=Object(C["a"])({history:Object(C["b"])(),routes:oa}),ra=na,ia=Object(T["createApp"])(x);ia.use(h.a),ia.use(s.a),ia.use(j.a),ia.use(f.a),ia.use(p.a),ia.use(b.a),ia.use(r.a),ia.use(o.a),ia.use(c.a),ia.use(ra),ia.mount("#app")},7849:function(e,t,a){e.exports=a.p+"img/three.15b713f5.png"},7900:function(e,t,a){},8784:function(e,t,a){},"88a7":function(e,t,a){"use strict";a("d57b")},c131:function(e,t,a){e.exports=a.p+"img/horizontally-vertically4.8c164e93.png"},c435:function(e,t,a){"use strict";a("7900")},c48d:function(e,t,a){e.exports=a.p+"img/horizontally-vertically2.5cd33807.png"},cd84:function(e,t,a){},d09a:function(e,t,a){"use strict";a("de8a")},d1ff:function(e,t,a){},d57b:function(e,t,a){},de8a:function(e,t,a){},f3ea:function(e,t,a){e.exports=a.p+"img/horizontal-center.6344d60d.png"},fd44:function(e,t,a){"use strict";a("8784")}});
//# sourceMappingURL=app.0f9e81f8.js.map