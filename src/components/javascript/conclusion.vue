<template>
  <div>
    <h2>JavaScript</h2>
    <p v-html="content1"></p>
    <h3>JS数据类型</h3>
    <ul>
        <li>基本数据类型: Undefined、Null、Boolean、Number、String、Symbol</li>
        <li>复杂数据类型: Object （Array、Date）</li>
    </ul>
    <p>区别：</p>
    <p class="a">基本数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</p>
    <h3>堆和栈</h3>
    <ul>
        <li>在数据结构中，栈中数据的存取方式为先进后出。而堆是一个优先队列，是按优先级来进行排序的。</li>
        <li>在操作系统中，内存被分为栈区和堆区。基本数据类型直接存储在栈中，复杂数据类型存储在堆中。</li>
    </ul>
    <h3>内部属性 [[Class]] </h3>
    <p>所有 typeof 返回值为 "object" 的对象（如数组）都包含一个内部属性 [[Class]]（我们可以把它看作一个内部的分类，而非传统的面向对象意义上的类）。这个属性无法直接访问，一般通过 Object.prototype.toString(..) 来查看。</p>
    <h3>JS创建对象的方式</h3>
    <p>我们一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。我了解到的创建大量对象的方式有：</p>
    <ul>
        <li>工厂模式:工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它不能识别特定类型。</li>
        <li>构造函数模式：用this创建属性和方法，能表示特定类型，但方法会被重复创建。</li>
        <li>原型模式:在函数的prototype属性上创建对象的属性和方法。</li>
        <li>组合模式：通过构造函数初始化对象的属性，通过原型实现方法的复用。</li>
        <li>类</li>
    </ul>
    <h3>预解析和执行</h3>
    <p>在预解析阶段，会创建执行上下文，执行上下文分为：
        <ul>
            <li>全局执行上下文</li>
            <li>函数执行上下文</li>
            <li>Eval执行上下文</li>
        </ul>
    </p>
    
    <p>一个执行上下文含：
        <ul>
            <li>变量对象：用来存放函数和变量</li>
            <li>作用域链：各级执行上下文的变量对象组成的链表</li>
            <li>this</li>
        </ul>
    </p>
    
    <p>预解析阶段，变量对象含：
        <ul>
            <li>根据函数参数创建的arguments对象</li>
            <li>寻找函数声明，若有，则将函数声明和引用存入变量对象。</li>
            <li>寻找变量声明，若有，则将变量名存入变量对象，并初始化undefined。</li>
        </ul>
    </p>
    <h3>this指向</h3>
    <ul>
        <li>直接作为函数来调用时，this 指向全局对象。</li>
        <li>作为一个对象的方法来调用时，this 指向这个对象。</li>
        <li>apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。</li>
        <li>用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。</li>
    </ul>
    <p>大多数情况下，this指向最后调用它的对象，箭头函数没有自己的this指向，它继承上一级作用域的this指向。</p>
    <h3>闭包</h3>
    <p>含义：函数和函数可以访问的变量对象的总和。</p>
    <p>从理论上说，JS中所有的函数都是闭包。在实际应用中，通常在函数的内部再创建一个函数，那么创建的函数就可以访问当前函数作用域中的变量对象，此时内部函数和外部函数的变量对象就形成了闭包。</p>
    <p>作用：
        <ul>
            <li>通过使用闭包，可以从函数外部调用闭包函数从而访问函数内部的变量。</li>
            <li>闭包也可以让已经结束运行的函数的变量对象保留下来不被垃圾回收机制回收。</li>
        </ul>
    </p>
    <h3>new操作符</h3>
    <p>作用：
        <ul>
            <li>首先创建了一个新的空对象</li>
            <li>设置原型，将对象的原型设置为函数的 prototype 对象。</li>
            <li>让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）。</li>
            <li>判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</li>
        </ul>
    </p>
    <h3>DOM和BOM</h3>
    <p>DOM 指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。</p>
    <p>BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM的核心是 window。</p>
    
    <h3>事件</h3>
    <p>含义：事件是用户操作网页时发生的交互动作，比如 click/move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。</p>
    <p>事件处理机制：
        <ul>
            <li>事件冒泡</li>
            <li>事件捕获</li>
        </ul>
    </p>
    <p>阻止冒泡方法：event.stopPropagation() 或者 event.cancelBubble = true。</p>
    <p>三种事件模型：
        <ul>
            <li>DOM0级：这种模型不会传播。</li>
            <li>DOM1级：在该事件模型中，一次事件共有两个过程，事件目标阶段和事件冒泡阶段。事件目标阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。</li>
            <li>DOM2级：在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。</li>
        </ul>
    </p>
  
  
  </div>
</template>

<script>
export default {
  name: 'conclusion_js',
  props: {
    
  },
  data() {
      return {
         content1: '<p>含义：JavaScript 是一种轻量级的编程语言,用于实现网页间的交互。</p>'
      }
  }
}
</script>

<!-- Add "scoped" attribute to limit CSS to this component only -->
<style scoped>
.a {
    margin-left: 20px;
}
</style>