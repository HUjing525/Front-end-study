<template>
  <div>
    <h2>传输层</h2>
    <p>含义：传输层协议主要是为不同主机上的不同进程间提供了逻辑通信的功能。</p>
    <h3>多路复用和多路分解：</h3>
    <ul>
        <li>一个信道同时传输多路信号是多路复用。</li>
        <li>将多路信号交付给对应的接收端是多路分解。</li>
    </ul>
    <p>无连接的多路复用和多路分解指的是 UDP 套接字的分配过程，一个 UDP 套接字由一个二元组来标识，这个二元组包含了一个目的地址和一个目的端口号。</p>
    <p>面向连接的多路复用和多路分解指的是 TCP 套接字的分配过程，一个 TCP 套接字由一个四元组来标识，这个四元组包含了源 IP 地址、源端口号、目的地址和目的端口号。</p>
    
    <h3>UDP协议</h3>
    <p>含义：UDP 是一种无连接的，不可靠的传输层协议。</p>
    <p>特点：</p>
    <ul>
        <li>使用 UDP 时，在发送报文段之前，通信双方没有握手的过程，因此 UDP 被称为是无连接的传输层协议。</li>
        <li>UDP 协议不保证数据的可靠交付。</li>
    </ul>
    <p>UDP 报文段结构：</p>
    <p>UDP 报文段由首部和应用数据组成。报文段首部包含四个字段，分别是源端口号、目的端口号、长度和检验和。</p>
    
    <h3>TCP协议</h3>
    <p>含义：TCP 协议是面向连接的，提供可靠数据传输服务的传输层协议。</p>
    <p>特点：</p>
    <ul>
        <li>TCP 协议是面向连接的，在通信双方进行通信前，需要通过三次握手建立连接。</li>
        <li>TCP 协议通过序号、确认号、定时重传、检验和等机制，来提供可靠的数据传输服务。</li>
        <li>TCP 提供了流量控制机制和拥塞控制机制。</li>
    </ul>
    
    <h3>TCP三次握手过程</h3>
    <ol>
        <li>客户端向服务器发送一个 SYN 连接请求报文段以及客户端数据的初始序号。</li>
        <li>服务器端接收到客户端发送的 SYN 连接请求报文段后，向客户端发送 SYN ACK 报文段以及服务器端数据的初始序号。</li>
        <li>客户端接收到服务器的肯定应答后，它也会为这次 TCP 连接分配缓存和变量，同时向服务器端发送一个对服务器端的报文段的确认。</li>
    </ol>
    <h3>TCP四次挥手过程</h3>
    <ol>
        <li>客户端认为没有数据要再发送给服务器端，它就向服务器发送一个 FIN 报文段，申请断开客户端到服务器端的连接。发送后客户端进入 FIN_WAIT_1 状态。</li>
        <li>服务器端接收到客户端释放连接的请求后，向客户端发送一个确认报文段，表示已经接收到了客户端释放连接的请求，以后不再接收客户端发送过来的数据。但是因为连接是全双工的，所以此时，服务器端还可以向客户端发送数据。服务器端进入 CLOSE_WAIT 状态。客户端收到确认后，进入 FIN_WAIT_2 状态。</li>
        <li>服务器端发送完所有数据后，向客户端发送 FIN 报文段，申请断开服务器端到客户端的连接。发送后进入 LAS T_ACK 状态。</li>
        <li>客户端接收到 FIN 请求后，向服务器端发送一个确认应答，并进入 TIME_WAIT 阶段。该阶段会持续一段时间， 这个时间为报文段在网络中的最大生存时间，如果该时间内服务端没有重发请求的话，客户端进入 CLOSED 的状态。如果收到服务器的重发请求就重新发送确认报文段。服务器端收到客户端的确认报文段后就进入 CLOSED 状态，这样全双工的连接就被释放了。</li>
    </ol>

    <h3>TCP的可靠运输机制</h3>
    <ul>
        <li>TCP 的可靠运输机制是基于连续 ARQ 协议和滑动窗口协议的。</li>
        <li>TCP就是通过调整发送窗口的大小来控制发送速率，发送窗口的大小根据网络的拥塞程度动态变化。</li>
        <li>接收方使用的是累计确认的机制，对于所有按序到达的报文段，接收方返回一个报文段的肯定回答。如果收到了一个乱序的报文 段，那么接方会直接丢弃，并返回一个最近的按序到达的报文段的肯定回答。</li>
    </ul>

    <h3>TCP流量控制机制</h3>
    <p>目的：控制发送方的发送速率，保证接收方来得及接收。</p>
    <p>方法：接收方主要是通过接收窗口来告诉发送方自己所能接收的大小，发送方根据 接收方的接收窗口的大小来调整发送窗口的大小，以此来达到控制发送速率的目的。</p>
    
    <h3>TCP拥塞控制机制</h3>
    <p>目的：根据网络中的拥塞情况来控制发送方数据的发送速率。一方面是为了避免继续增加网络中的拥塞程度，另一方面也是为了避免网络拥塞可能造成的报文段丢失。</p>
    <p>TCP 的拥塞控制主要使用了四个机制:
        <ul>
            <li>慢启动:在发送方刚开始发送数据的时候，并不知道网络中的拥塞程度，所以先以较低的速率发送，进行试探 ，每次收到一个确认报文，就将发动窗口的长度加一，这样每个 RTT 时间后，发送窗口的长度就会加倍。当发送窗口的大小达到一个阈值的时候就进入拥塞避免算法。</li>
            <li>拥塞避免:为了避免可能发生的拥塞，将发送窗口的大小由每过一个 RTT 增长一倍，变为每过一个 RTT ，长度只加一。 这样将窗口的增长速率由指数增长，变为加法线性增长。</li>
            <li>快速重传:当发送方收到三个冗余的确认应答时，因为 TCP 使用的是累计确认的机制，所以很有可能是发生了报文段的 丢失，因此采用立即重传的机制，在定时器结束前发送所有已发送但还未接收到确认应答的报文段。</li>
            <li>快速恢复:因为网络中可能已经出现了拥塞情况，所以会将慢启动的阀值减小为原来的一半，然后将拥 塞窗口的值置为减半后的阀值，然后开始执行拥塞避免算法，使得拥塞窗口缓慢地加性增大。简单来理解就是，乘性减，加性增。</li>
        </ul>
    </p>
  </div>
</template>

<script>
export default {
  name: 'transport',
  props: {
    
  }
}
</script>

<!-- Add "scoped" attribute to limit CSS to this component only -->
<style scoped>

</style>
